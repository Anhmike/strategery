#' We will consider the Strategy class hierarchy and describe how a strategy can
#' be designed to handle multiple symbols, thus generating multiple SignalEvents
#' for the Portfolio object.
#' 
#' Strategy objects take market data as input and produce trading signal events 
#' as output.
#' 
#' A Strategy object encapsulates all calculations on market data that generate 
#' advisory signals to a Portfolio object. At this stage in the event-driven 
#' backtester development there is no concept of an indicator or filter, such as
#' those found in technical trading. These are also good candidates for creating
#' a class hierarchy but are beyond the scope of this article.
#' 
#' The strategy hierarchy is relatively simple as it consists of an abstract 
#' base class with a single pure virtual method for generating SignalEvent 
#' objects.
#' 
#' Strategy is an abstract base class providing an interface for all subsequent
#' (inherited) strategy handling objects. The goal of a (derived) Strategy 
#' object is to generate Signal objects for particular symbols based on the 
#' inputs of Bars (OLHCVI) generated by a DataHandler object. This is designed 
#' to work both with historic and live data as the Strategy object is agnostic 
#' to the data source, since it obtains the bar tuples from a queue object.
#' @include Queue.R
#' @include Event.R
#' @import data.table
Strategy <- setRefClass("Strategy", contains="VIRTUAL"
                        fields = list(
                        ),
                        methods = list(
                          calcSignals = function(m){
"The Strategy object utilises market data to create new SignalEvents. 
The SignalEvent contains a ticker symbol, a timestamp for when it was generated 
and a direction (long or short)."

stop("Should implement calcSignals()")
                            print("Signals calculated from market event")
                            return(list(symbol="AA", 
                                        timestamp=Sys.Date(),
                                        direction=1))
                          }
                        )
)

#' This is an extremely simple strategy that goes LONG all of the symbols as 
#' soon as a bar is received. It will never exit a position. 
#' 
#' It is primarily used as a testing mechanism for the Strategy class as well as
#' a benchmark upon which to compare other strategies.
#' @field bought 
#' On initialisation of the BuyAndHoldStrategy the bought dictionary member has
#' a set of keys for each symbol that are all set to FALSE. Once the asset has 
#' been "longed" then this is set to TRUE. Essentially this allows the Strategy
#' to know whether it is "in the market" or not.
BuyAndHoldStrategy <- setRefClass("BuyAndHoldStrategy", contains="Strategy"
                        fields = list(
                          bars="ANY", # TODO: specify bars class
                          symbols="character",
                          events="EventQueue", # TODO: not sure
                          bought="ANY" # TODO: figure out
                        ),
                        methods = list(
                          initialize = function(bars, events) {
  "Initialises the buy and hold strategy.
                      
  Parameters:
    bars - The DataHandler object that provides bar information
    events - The Event Queue object."
  
  bars <<- bars
  symbols <<- symbols
  events <<- events
  # Once buy & hold signal is given, these are set to TRUE
  bought <<- .calculateInitialBought()
                          },
  
                          calcSignals = function(m){
  "Loops over all symbols in the symbol list and retrieves the latest bar from the
  bars data handler. It then checks whether that symbol has been 'bought' (i.e. 
  whether we're in the market for this symbol or not) and if not creates a single
  SignalEvent object. This is then placed on the events queue and the bought 
  dictionary is correctly updated to True for this particular symbol key"
    
  if(m$type == 'MARKET'){
    for (s in symbols)
      bars = bars.getLatestBars(s, N=1)
    if (!is.null(bars)
      if (!bought[s]) {
        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
        events$put(signal)
        bought[s] <<- TRUE
      }
  }
                          },
  
                          .calculateInitialBought = function(){
  "Adds keys to the bought dictionary for all symbols and sets them to FALSE."
                            
  b = list()
  for (s in symbols)
    b[s] = FALSE
  return(b)
                          }
                        )
)


#' Start strategy definition
#' 
#' @export
newStrategy <- function (name) 
{
#   s <- list(name=name)
#   class(s) <- "strategy"
#   assign(name, s , envir=.GlobalEnv)
}

#' Save (persist) strategy definition
#' 
#' @export
saveStrategy <- function(
  # envir=strategy$name
)
{
#   s <- get("strategy", envir=.GlobalEnv)
# 
#   assign(strategy$name, s , envir=.GlobalEnv)
}